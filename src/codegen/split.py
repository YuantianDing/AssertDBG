
import re
import subprocess
from mirascope import BaseMessageParam
from mirascope.core import Messages, openai
from pydantic import BaseModel, Field, ValidationError
from termcolor import colored
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import TerminalFormatter

from src.codegen.intentcheck import intent_check, FunctionCode


class SplittedTask(BaseModel):
    """
    A programming task that has been splitted to multiple sub-functions.
    The main function will call the subfunctions in order to solve the task.
    The subfunctions are generated by the model.
    """
    main_func: FunctionCode = Field(description="The main function that calls the subfunctions.")
    subfunctions: list[FunctionCode] = Field(description="Each subfunctions that are called by the main function.")

    def combine(self) -> str:
        return "\n\n".join(f.code for f in [self.main_func] + self.subfunctions)
        
    def pretty_print(self, indent: str = ""):
        print(highlight(indent + self.combine().replace("\n", "\n" + indent), PythonLexer(), TerminalFormatter()))

@openai.call(model="gpt-4o", response_model=SplittedTask)
def split_inner(prompt: str):
    return [
        Messages.System(
            "In practical software engineering, large tasks are often broken down into smaller, focused subfunctions to improve readability, maintainability, and testability.\n"
            "\n"
            "You will be given a Python programming task. Your goal is to **decompose the task into multiple subfunctions**, each responsible for a clear, isolated part of the problem.\n"
            "\n"
            "Your output should include:\n"
            "\n"
            "- A **main function** which coordinates the solution by calling one or more subfunctions. \n"
            "  - You have to **provide an implementation for the main function**. \n"
            "  - Make sure to use **the exactly same function name** for the main function as given in the user's prompt. \n"
            "  - Your implementation must accurately match the **function signature** and **docstring** provided in the prompt. \n"
            "- For **each subfunction**, provide:\n"
            "  - The **function signature**, including type annotations for inputs and outputs.\n"
            "  - A clear **docstring** describing the purpose and behavior of the function.\n"
            "  - **Input/output assertions** that clarify what the function expects and guarantees.\n"
            "\n"
            "Guidelines:\n"
            "\n"
            "- You should try to use the simplest algorithm that guarrentee safety and reduce error. Try to **avoid complex algorithm and keep the codebase small** !!!!!!!!! \n"
            "- If there are **any common python libraries** (Sympy, for example) that already implemented the main functions or the subfunctions, **DO NOT REINVENT THE WHEEL** and implement the code yourself !!!!!!!\n"
            "- Say it again, use the common libraries !!! \n"
            "- Ensure that subfunctions are **independent**, reusable, and testable in isolation.\n"
            "- **Do not implement** the body of the subfunctions — only provide the interface, documentation, and assertions. Make sure to implement the main function. \n"
            "- Favor **keeping complexity in the subfunctions** and the main function **as simple as possible**.\n"
            "- If the task is very simple, it’s acceptable to avoid using subfunctions.\n"
            "- Include the **task description as a docstring** in the generated code.\n"
            "\n"
            "This decomposition will serve as a blueprint for implementing and testing the task effectively.\n"
        ),
        Messages.User(prompt)
    ]

def split(prompt: str) -> SplittedTask:
    f = None
    for _ in range(3):
        try:
            f = split_inner(prompt)
        except ValidationError as e:
            print(colored(f"Validation Error: split {e}", "red"))
            continue
        match = re.search(r'("""(.*?)""")', prompt, flags=re.DOTALL)
        if match:
            doc = match.group(2).strip()
        else:
            doc = ""

        f.main_func.code = re.sub(r'(""".*?""")', f'"""{doc}"""', f.main_func.code, count=1, flags=re.DOTALL)
        if intent_check(f.main_func):
            return f
    return f