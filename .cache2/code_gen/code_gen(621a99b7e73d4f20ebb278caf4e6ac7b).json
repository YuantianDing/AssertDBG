{"in": {"attempt": -1, "prompt": "\ndef even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n", "with_assert": true, "verbose": 2}, "out": {"main_func": {"function_name": "even_odd_count", "code": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    \n    def extract_digits(num):\n        digits = list(str(abs(num)))\n        assert all(digit.isdigit() for digit in digits), f\"All characters should be digits, got: {digits}\"\n        return digits\n    \n    def count_even_digits(digits):\n        even_digits = [digit for digit in digits if int(digit) % 2 == 0]\n        count = len(even_digits)\n        assert count >= 0 and count <= len(digits), f\"Number of even digits {count} must be between 0 and total digits {len(digits)}\"\n        return count\n\n    def count_odd_digits(digits):\n        odd_digits = [digit for digit in digits if int(digit) % 2 != 0]\n        count = len(odd_digits)\n        assert count >= 0 and count <= len(digits), f\"Number of odd digits {count} must be between 0 and total digits {len(digits)}\"\n        return count\n\n    assert isinstance(num, int), f\"The input must be an integer, got: {type(num)}\"\n\n    digits = extract_digits(num)\n    evens = count_even_digits(digits)\n    odds = count_odd_digits(digits)\n\n    result = (evens, odds)\n    assert (evens + odds) == len(digits), f\"Sum of evens {evens} and odds {odds} must equal the total number of digits {len(digits)}\"\n    assert isinstance(result, tuple) and len(result) == 2, f\"The result must be a tuple of size 2, got: {result}\"\n    return result\n"}, "subfunctions": [{"function_name": "extract_digits", "code": "def extract_digits(num: int) -> list[int]:\n    \"\"\"\n    Extract digits from the given integer, returning a list of digits.\n\n    :param num: An integer from which to extract digits.\n    :returns: A list of individual digits from the integer.\n    \"\"\"\n    assert isinstance(num, int), f\"Input must be an integer, got {type(num)}.\"\n    num = abs(num)  # Ensure positive representation by using absolute value\n    digits = [int(digit) for digit in str(num)]\n    assert all(isinstance(d, int) for d in digits), \"All elements of output must be integers.\"\n    assert all(0 <= d <= 9 for d in digits), \"All elements of output must be single digits (0-9).\"\n    \n    # The output should properly represent the input number's digits\n    reconstructed_num = int(''.join(map(str, digits)))\n    assert reconstructed_num == num, f\"Reconstructed number {reconstructed_num} does not match the original {num}.\"\n    \n    return digits\n"}, {"function_name": "count_even_digits", "code": "def count_even_digits(digits: list[int]) -> int:\n    \"\"\"\n    Count the number of even digits in the list.\n\n    :param digits: A list of digits to count even numbers from.\n    :returns: The count of even digits in the list.\n    \"\"\"\n    assert all(isinstance(digit, int) for digit in digits), \"All elements must be integers.\"\n    assert all(0 <= digit <= 9 for digit in digits), \"All elements in 'digits' must be single-digit integers.\"\n\n    even_count = sum(1 for digit in digits if digit % 2 == 0)\n    assert isinstance(even_count, int), f\"Output should be an int, got {type(even_count).__name__} instead.\"\n    assert 0 <= even_count <= len(digits), f\"Output count {even_count} should be within 0 and the number of input digits {len(digits)}.\"\n\n    return even_count\n"}, {"function_name": "count_odd_digits", "code": "def count_odd_digits(digits: list[int]) -> int:\n    \"\"\"\n    Count the number of odd digits in the list.\n\n    :param digits: A list of digits to count odd numbers from.\n    :returns: The count of odd digits in the list.\n    \"\"\"\n    assert all(isinstance(digit, int) for digit in digits), \"All elements must be integers.\"\n    \n    # Initialize a counter for odd digits\n    odd_count = 0\n    \n    # Iterate through the list and count odd digits\n    for digit in digits:\n        assert isinstance(digit, int), f\"Expected int, got {type(digit)} for digit {digit}\"\n        if digit % 2 != 0:  # If the digit is odd\n            odd_count += 1\n        # Ensure odd_count is always a non-negative integer\n        assert odd_count >= 0, f\"Odd count {odd_count} should be non-negative.\"\n    \n    # Ensure the result is valid by definition\n    assert 0 <= odd_count <= len(digits), f\"The odd count {odd_count} must be between 0 and {len(digits)} inclusive.\"\n    \n    return odd_count\n"}]}}