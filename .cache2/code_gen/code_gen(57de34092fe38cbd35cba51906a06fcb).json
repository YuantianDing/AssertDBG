{"in": {"attempt": -1, "prompt": "\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n", "with_assert": true, "verbose": 2}, "out": {"main_func": {"function_name": "is_nested", "code": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n    assert isinstance(string, str), f\"Expected string to be a str, but got {type(string).__name__} with value {string}\"\n    assert all(c in '[]' for c in string), \"Input string can only contain '[' and ']'\"\n\n    stack = []\n    nested_found = False\n\n    for index, char in enumerate(string):\n        assert char in '[]', f\"Unexpected character {char} at position {index}\"\n        if char == '[':\n            stack.append(char)\n            assert len(stack) > 0, f\"Invalid stack state after pushing: {stack}\"\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                nested_found = True\n            assert not (char == ']' and not stack), f\"Stack underflow at index {index} with stack: {stack}\"\n        else:\n            return False\n\n    assert isinstance(nested_found, bool), f\"Expected nested_found to be bool, but got {type(nested_found).__name__}\"\n    # Validating the condition of the valid subsequence of nested brackets\n    unmatched_opening = stack.count('[')\n    assert unmatched_opening >= 0, f\"Unmatched opening brackets: {unmatched_opening}\"    \n    return nested_found"}, "subfunctions": [{"function_name": "process_brackets", "code": "def process_brackets(char: str, stack: list, nested_found: bool) -> bool:\n    '''\n    Process a bracket character and update the stack and nested_found status.\n\n    Args:\n        char (str): The current character to process, expected to be '[' or ']'.\n        stack (list): The other brackets that currently remain unmatched.\n        nested_found (bool): Boolean indicating if a nested bracket has been found.\n\n    Returns:\n        bool: The updated nested_found status.\n    '''\n    \n    assert char in ['[', ']'], \"The input must be a bracket ('[' or ']'). Received: {}\".format(char)\n    assert isinstance(stack, list), \"The stack should be a list. Received: {}\".format(type(stack))\n    assert isinstance(nested_found, bool), \"nested_found should be a boolean. Received: {}\".format(type(nested_found))\n\n    initial_stack_len = len(stack)\n    initial_nested_found = nested_found\n\n    if char == '[':\n        stack.append(char)\n    elif char == ']' and stack:\n        stack.pop()\n        if stack:\n            nested_found = True\n    else:\n        return nested_found\n\n    assert (nested_found == initial_nested_found or nested_found is True), (\n        \"nested_found must remain the same or be updated to True. Initial: {}, Final: {}\".format(initial_nested_found, nested_found)\n    )\n    assert len(stack) == initial_stack_len + (1 if char == '[' else -1 if char == ']' and initial_stack_len > 0 else 0), (\n        \"Stack length inconsistency. Expected change based on char '{}', initial stack length: {}, final stack length: {}\"\n        .format(char, initial_stack_len, len(stack))\n    )\n\n    return nested_found\n"}]}}