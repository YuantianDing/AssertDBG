{"in": {"code": {"main_func": {"function_name": "order_by_points", "code": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(x):\n        # Calculate the sum of the absolute value of the digits of x\n        return sum(int(d) for d in str(abs(x)))\n    \n    assert isinstance(nums, list), \"Input must be a list, got {}\".format(type(nums))\n    for i, num in enumerate(nums):\n        assert isinstance(num, int), \"Each element in nums must be an integer, got element {} at index {} of type {}\".format(num, i, type(num))\n    \n    # Use enumerate directly in the sorting key to avoid issues when numbers are repeated\n    result = sorted(enumerate(nums), key=lambda x: (digit_sum(x[1]), x[0]))\n    \n    # Extract the sorted numbers from the result which contains tuples (index, num)\n    result = [x[1] for x in result]\n\n    assert isinstance(result, list), \"Output must be a list, got {}\".format(type(result))\n    for i in range(1, len(result)):\n        sum_prev = digit_sum(result[i - 1])\n        sum_curr = digit_sum(result[i])\n        assert sum_prev <= sum_curr, \"List is not sorted by digit sum: {} (sum {}) > {} (sum {}) at indices {} and {}\".format(\n            result[i - 1], sum_prev, result[i], sum_curr, i - 1, i\n        )\n        # Fix this line to properly use the first occurring item's index for stable sort\n        if sum_prev == sum_curr:\n            index_prev = nums.index(result[i - 1])\n            index_curr = nums.index(result[i], index_prev+1)\n            assert index_prev < index_curr, \"Items with the same digit sum are out of order based on original list indices: \" \\\n                                           \"index {} in original > index {} for {} and {}\".format(\n                index_prev, index_curr, result[i - 1], result[i]\n            )\n    return result\n"}, "subfunctions": [{"function_name": "digit_sum", "code": "def digit_sum(num: int) -> int:\n    \"\"\"\n    Calculate the sum of digits of a given integer.\n    Handles both positive and negative numbers by considering absolute value.\n\n    :param num: Integer whose digit sum is to be calculated.\n    :return: Sum of digits of the integer.\n    \"\"\"\n    assert isinstance(num, int), f\"Input must be an integer, got {type(num)} with value {num}\"\n    \n    # Use absolute value to handle negative numbers\n    num = abs(num)\n    \n    # Convert the number to a string to iterate over digits\n    num_str = str(num)\n    assert num_str.isdigit(), f\"After conversion to absolute, expected numeric string, got {num_str}\"\n    \n    # Sum the digits\n    digit_sum_result = sum(int(digit) for digit in num_str)\n    \n    assert isinstance(digit_sum_result, int), f\"Output must be an integer, got {type(digit_sum_result)}\"\n    assert digit_sum_result >= 0, f\"Sum of digits should not be negative, got {digit_sum_result}\"\n    \n    return digit_sum_result\n"}]}, "test": {"function_name": "test_order_by_points", "code": "import random\n\ndef test_order_by_points():\n    # Helper function to calculate the sum of digits of a number\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Generate random test cases\n    for _ in range(1000):\n        # Generate a random list of integers with length between 1 and 10\n        nums = [random.randint(-1000, 1000) for _ in range(random.randint(1, 10))]\n        \n        # Sort expected list with custom logic\n        expected = sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n        \n        # Call the function and assert if the result matches the expected\n        assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n\n    \n    # Edge cases\n    # Test with empty list\n    assert order_by_points([]) == [], \"Failed for empty list\"\n\n    # Test with all elements having the same digit sum\n    nums = [11, 20, 2, 101]  # All have sum of digits == 2\n    expected = sorted(nums, key=lambda x: nums.index(x))  # Should remain in original order\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n\n    # Test with negative and positive numbers\n    nums = [1, 11, -1, -11, -12]\n    expected = [-1, -11, 1, -12, 11]\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n\n    # Test with numbers having both positive and negative digits summing to the same\n    nums = [10, -19, -82]\n    expected = [10, -19, -82]  # Order should remain as by their original position since sums are equal\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n\n    # Test with repeated numbers\n    nums = [5, 5, 5, 6, 6, 6]\n    expected = nums[:]\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n\n    # Test with large maximum digits\n    nums = [9999, 8888, 7777, 2222]\n    expected = [2222, 8888, 7777, 9999]  # Order by digit sums 8, 32, 28, 36\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\""}, "error": "Traceback (most recent call last):\n  File \"/tmp/assertdbg.py\", line 134, in <module>\n    test_order_by_points()\n  File \"/tmp/assertdbg.py\", line 118, in test_order_by_points\n    assert order_by_points(nums) == expected, f\"Failed for list: {nums}\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Failed for list: [1, 11, -1, -11, -12]\n", "verbose": 2}, "out": {"inner": {"action": "fix_code", "functions": [{"function_name": "order_by_points", "code": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in the original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(x):\n        # Calculate the sum of the absolute value of the digits of x\n        return sum(int(d) for d in str(abs(x)))\n    \n    assert isinstance(nums, list), \"Input must be a list, got {}\".format(type(nums))\n    for i, num in enumerate(nums):\n        assert isinstance(num, int), \"Each element in nums must be an integer, got element {} at index {} of type {}\".format(num, i, type(num))\n    \n    # Use enumerate directly in the sorting key to avoid issues when numbers are repeated\n    result = sorted(enumerate(nums), key=lambda x: (digit_sum(x[1]), x[0]))\n    \n    # Extract the sorted numbers from the result which contains tuples (index, num)\n    result = [x[1] for x in result]\n\n    assert isinstance(result, list), \"Output must be a list, got {}\".format(type(result))\n    for i in range(1, len(result)):\n        sum_prev = digit_sum(result[i - 1])\n        sum_curr = digit_sum(result[i])\n        assert sum_prev <= sum_curr, \"List is not sorted by digit sum: {} (sum {}) > {} (sum {}) at indices {} and {}\".format(\n            result[i - 1], sum_prev, result[i], sum_curr, i - 1, i\n        )\n        # Fix this line to properly use the first occurring item's index for stable sort\n        if sum_prev == sum_curr:\n            index_prev = nums.index(result[i - 1])\n            index_curr = nums.index(result[i])  # Only searching for index_curr once\n            assert index_prev < index_curr, \"Items with the same digit sum are out of order based on original list indices: \" \\\n                                           \"index {} in original > index {} for {} and {}\".format(\n                index_prev, index_curr, result[i - 1], result[i]\n            )\n    return result\n"}]}}}