{"_default": {"1": {"task_id": "BigCodeBench/13", "function_name": "task_func", "code": "def task_func(ftp_server: str = 'ftp.dlptest.com', ftp_user: str = 'dlpuser', ftp_password: str = 'rNrKYTX9g7z3RgJRmxWuGHbeu', ftp_dir: str = '/ftp/test') -> list:\n    \"\"\"\n    Download all files from a specific directory on an FTP server using wget in a subprocess.\n\n    Args:\n    ftp_server (str): The FTP server address. Default is 'ftp.dlptest.com'.\n    ftp_user (str): The FTP server username. Default is 'dlpuser'.\n    ftp_password (str): The FTP server password. Default is 'rNrKYTX9g7z3RgJRmxWuGHbeu'.\n    ftp_dir (str): The directory path on the FTP server from which files need to be downloaded. Default is '/ftp/test'.\n\n    Returns:\n    List[str]: A list of filenames that were attempted to be downloaded from the FTP server.\n\n    Raises:\n    Exception: \n        - If there is a failure in connecting to the FTP server. Outputs the message \"Failed to connect to FTP server {ftp_server}: {str(e)}\"\n        - If there is a failure in logging into the FTP server. Outputs the message \"Failed to log into FTP server {ftp_server} with user {ftp_user}: {str(e)}\"\n        - If there is a failure in changing to the specified directory. Outputs the message \"Failed to change to directory {ftp_dir} on server {ftp_server}: {str(e)}\"\n    \"\"\"\n    # Input assertions\n    assert isinstance(ftp_server, str) and ftp_server, f'ftp_server must be a non-empty string, got {ftp_server} of type {type(ftp_server)}'\n    assert isinstance(ftp_user, str) and ftp_user, f'ftp_user must be a non-empty string, got {ftp_user} of type {type(ftp_user)}'\n    assert isinstance(ftp_password, str) and ftp_password, f'ftp_password must be a non-empty string, got {ftp_password} of type {type(ftp_password)}'\n    assert isinstance(ftp_dir, str) and ftp_dir, f'ftp_dir must be a non-empty string, got {ftp_dir} of type {type(ftp_dir)}'\n\n    ftp_connection = connect_ftp(ftp_server, ftp_user, ftp_password)\n    assert ftp_connection is not None, f'connect_ftp returned None for ftp_server: {ftp_server}, ftp_user: {ftp_user}'\n\n    change_directory(ftp_connection, ftp_dir)\n\n    filenames = list_files(ftp_connection)\n    assert isinstance(filenames, list), f'list_files must return a list, got {type(filenames)} with value {filenames}'\n    for filename in filenames:\n        assert isinstance(filename, str), f'Each filename must be a string, got {filename} of type {type(filename)}'\n\n    download_files_with_wget(filenames, ftp_server, ftp_user, ftp_password, ftp_dir)\n\n    # Final output assertion\n    assert isinstance(filenames, list), f'Final output must be a list, got {type(filenames)} with value {filenames}'\n    for filename in filenames:\n        assert isinstance(filename, str), f'Final output list must contain strings, found element {filename} of type {type(filename)}'\n    return filenames\n\n\nfrom ftplib import FTP\n\ndef connect_ftp(ftp_server: str, ftp_user: str, ftp_password: str) -> object:\n    \"\"\"\n    Connect to the FTP server using the provided credentials.\n\n    Args:\n        ftp_server (str): The FTP server address.\n        ftp_user (str): The FTP server username.\n        ftp_password (str): The FTP server password.\n\n    Returns:\n        object: An FTP connection object if successful.\n\n    Raises:\n        Exception: If there is a failure in connecting to or logging into the FTP server.\n    \"\"\"\n    assert isinstance(ftp_server, str), f\"ftp_server must be a string, got {type(ftp_server)}\"\n    assert isinstance(ftp_user, str), f\"ftp_user must be a string, got {type(ftp_user)}\"\n    assert isinstance(ftp_password, str), f\"ftp_password must be a string, got {type(ftp_password)}\"\n    try:\n        ftp = FTP(ftp_server)\n        ftp.login(user=ftp_user, passwd=ftp_password)\n    except Exception as e:\n        raise Exception(f\"Failed to connect or log into FTP server {ftp_server} with user {ftp_user}: {str(e)}\")\n    assert isinstance(ftp, FTP), f\"ftp is not an instance of FTP, got {type(ftp)}\"\n    assert hasattr(ftp, 'sock'), f\"ftp object missing socket attribute 'sock'. ftp details: {ftp}\"\n    assert ftp.sock is not None, f\"FTP connection socket is None. ftp details: {ftp}\"\n    return ftp\n\n\ndef change_directory(ftp_connection: object, ftp_dir: str) -> None:\n    \"\"\"\n    Change the current directory on the FTP server.\n\n    Args:\n        ftp_connection (object): The active FTP connection.\n        ftp_dir (str): The directory path to switch to on the FTP server.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: If there is a failure in changing the directory.\n    \"\"\"\n    assert ftp_connection is not None, f\"ftp_connection is None; ftp_dir={ftp_dir}\"\n    assert isinstance(ftp_dir, str), f\"ftp_dir must be a string; got {type(ftp_dir)} with value {ftp_dir}\"\n    assert ftp_dir != \"\", f\"ftp_dir must be non-empty; ftp_dir={ftp_dir}\"\n    assert hasattr(ftp_connection, 'cwd') and callable(ftp_connection.cwd), f\"ftp_connection must have a callable 'cwd' attribute; ftp_connection={ftp_connection}\"\n    \n    try:\n        ftp_connection.cwd(ftp_dir)\n    except Exception as e:\n        raise Exception(f\"Failed to change to directory {ftp_dir}: {str(e)}\")\n    \n    if hasattr(ftp_connection, 'pwd') and callable(ftp_connection.pwd):\n        current_dir = ftp_connection.pwd()\n        assert current_dir == ftp_dir, f\"Post-condition failed: expected current directory {ftp_dir}, got {current_dir}\"\n\ndef list_files(ftp_connection: object) -> list:\n    \"\"\"\n    List all files in the current FTP directory.\n\n    Args:\n        ftp_connection (object): The active FTP connection.\n\n    Returns:\n        list: A list of filenames present in the current directory.\n\n    Raises:\n        Exception: If the listing of files fails.\n    \"\"\"\n    assert ftp_connection is not None, f\"ftp_connection is None. Provided ftp_connection: {ftp_connection}\"\n    try:\n        files = ftp_connection.nlst()\n        assert files is not None, \"nlst() returned None instead of an iterable.\"\n        if not isinstance(files, list):\n            files = list(files)\n        for index, filename in enumerate(files):\n            assert isinstance(filename, str), f\"Item at index {index} in files is not a string. Found type: {type(filename)} with value: {filename}\"\n        assert isinstance(files, list), f\"files is not a list after conversion. Found type: {type(files)}\"\n        return files\n    except Exception as e:\n        raise Exception(f\"Failed to list files in FTP directory: {str(e)}\")\n\n\nimport subprocess\nimport os\n\ndef download_files_with_wget(filenames: list, ftp_server: str, ftp_user: str, ftp_password: str, ftp_dir: str) -> None:\n    \"\"\"\n    Download the specified files from the FTP directory using wget in a subprocess.\n\n    Args:\n        filenames (list): The list of file names to download.\n        ftp_server (str): The FTP server address.\n        ftp_user (str): The FTP server username.\n        ftp_password (str): The FTP server password.\n        ftp_dir (str): The directory path on the FTP server.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: If there is a failure in executing the wget command.\n    \"\"\"\n    assert isinstance(filenames, list), f\"filenames must be a list, got {type(filenames)}\"\n    assert isinstance(ftp_server, str), f\"ftp_server must be a string, got {type(ftp_server)}\"\n    assert isinstance(ftp_user, str), f\"ftp_user must be a string, got {type(ftp_user)}\"\n    assert isinstance(ftp_password, str), f\"ftp_password must be a string, got {type(ftp_password)}\"\n    assert isinstance(ftp_dir, str), f\"ftp_dir must be a string, got {type(ftp_dir)}\"\n    \n    for filename in filenames:\n        assert isinstance(filename, str), f\"Each filename must be a string, got {type(filename)} with value {filename}\"\n        ftp_dir_clean = ftp_dir.rstrip('/')\n        ftp_url = f\"ftp://{ftp_user}:{ftp_password}@{ftp_server}{ftp_dir_clean}/{filename}\"\n        assert ftp_url.startswith('ftp://'), f\"ftp_url must start with 'ftp://', got {ftp_url}\"\n        command = [\"wget\", ftp_url]\n        try:\n            result = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            # Loop invariant: Ensure the subprocess returned a completed process with returncode 0\n            assert result.returncode == 0, f\"Subprocess for {ftp_url} exited with non-zero code {result.returncode}\"\n        except subprocess.CalledProcessError as e:\n            error_message = e.stderr.decode('utf-8').strip() if e.stderr else 'No error message'\n            raise Exception(f\"Failed to download file {filename} from {ftp_url}: {error_message}\") from e\n    \n    ret = None\n    assert ret is None, f\"Function should return None, but got {ret}\"", "testing": false, "error_message": "EFFFF\n======================================================================\nERROR: test_case_1 (__test__.TestCases.test_case_1)\nTest with default parameters and successful download.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 163, in change_directory\n    ftp_connection.cwd(ftp_dir)\n    ~~~~~~~~~~~~~~~~~~^^^^^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ftplib.py\", line 619, in cwd\n    return self.voidcmd(cmd)\n           ~~~~~~~~~~~~^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ftplib.py\", line 286, in voidcmd\n    return self.voidresp()\n           ~~~~~~~~~~~~~^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ftplib.py\", line 259, in voidresp\n    resp = self.getresp()\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/ftplib.py\", line 254, in getresp\n    raise error_perm(resp)\nftplib.error_perm: 550 Failed to change directory.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 262, in test_case_1\n    downloaded_files = task_func()\n  File \"/tmp/testing_python_program.py\", line 96, in task_func\n    change_directory(ftp_connection, ftp_dir)\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/testing_python_program.py\", line 165, in change_directory\n    raise Exception(f\"Failed to change to directory {ftp_dir}: {str(e)}\")\nException: Failed to change to directory /ftp/test: 550 Failed to change directory.\n\n======================================================================\nFAIL: test_case_2 (__test__.TestCases.test_case_2)\nTest with an invalid FTP server by raising an exception on connect.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 273, in test_case_2\n    self.assertEqual(str(context.exception), f'Failed to connect to FTP server invalid_server: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Failed to connect or log into FTP server invalid_server wit[66 chars]nown' != 'Failed to connect to FTP server invalid_server: Failed to c[16 chars]rver'\n- Failed to connect or log into FTP server invalid_server with user dlpuser: [Errno 8] nodename nor servname provided, or not known\n+ Failed to connect to FTP server invalid_server: Failed to connect to FTP server\n\n\n======================================================================\nFAIL: test_case_3 (__test__.TestCases.test_case_3)\nTest with an invalid FTP user by raising an exception on login.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 281, in test_case_3\n    self.assertEqual(str(context.exception), f'Failed to log into FTP server ftp.dlptest.com with user invalid_user: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Failed to connect or log into FTP server ftp.dlptes[46 chars]ect.' != 'Failed to log into FTP server ftp.dlptest.com with [30 chars]ogin'\n- Failed to connect or log into FTP server ftp.dlptest.com with user invalid_user: 530 Login incorrect.\n?          -----------                                                             ^^^^^    -----------\n+ Failed to log into FTP server ftp.dlptest.com with user invalid_user: Failed to login\n?                                                                       ^^^^^^^^^^^\n\n\n======================================================================\nFAIL: test_case_4 (__test__.TestCases.test_case_4)\nTest with an invalid FTP password by raising an exception on login.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 289, in test_case_4\n    self.assertEqual(str(context.exception), f'Failed to log into FTP server ftp.dlptest.com with user dlpuser: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Failed to connect or log into FTP server ftp.dlptes[41 chars]ect.' != 'Failed to log into FTP server ftp.dlptest.com with [25 chars]ogin'\n- Failed to connect or log into FTP server ftp.dlptest.com with user dlpuser: 530 Login incorrect.\n?          -----------                                                        ^^^^^    -----------\n+ Failed to log into FTP server ftp.dlptest.com with user dlpuser: Failed to login\n?                                                                  ^^^^^^^^^^^\n\n\n======================================================================\nFAIL: test_case_5 (__test__.TestCases.test_case_5)\nTest with an invalid FTP directory by raising an exception on cwd.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 297, in test_case_5\n    self.assertEqual(str(context.exception), f'Failed to change to directory /invalid_directory on server ftp.dlptest.com: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Fail[36 chars]irectory: 550 Failed to change directory.' != 'Fail[36 chars]irectory on server ftp.dlptest.com: Failed to change directory'\n- Failed to change to directory /invalid_directory: 550 Failed to change directory.\n?                                                  ----                           -\n+ Failed to change to directory /invalid_directory on server ftp.dlptest.com: Failed to change directory\n?                                                 ++++++++++++++++++++++++++\n\n\n----------------------------------------------------------------------\nRan 5 tests in 8.186s\n\nFAILED (failures=4, errors=1)\n"}, "2": {"task_id": "BigCodeBench/15", "function_name": "task_func", "code": "import os\n\n\ndef read_commands_from_csv(commands_file_path: str) -> list:\n    \"\"\"Read shell commands from a CSV file.\"\"\"\n    assert isinstance(commands_file_path, str), f\"commands_file_path must be a string, got {commands_file_path} (type {type(commands_file_path)})\"\n    # Placeholder implementation\n    # In a real scenario, read from CSV and return list of commands\n    commands = []\n    # Example invariant: commands is a list of strings\n    assert isinstance(commands, list), f\"Expected commands to be list, got {type(commands)}\"\n    for idx, cmd in enumerate(commands):\n        assert isinstance(cmd, str), f\"Each command must be a string. Error at index {idx}: {cmd} (type {type(cmd)})\"\n    return commands\n\n\ndef ensure_directory_exists(output_dir_path: str) -> None:\n    \"\"\"Ensure the output directory exists, create if not.\"\"\"\n    assert isinstance(output_dir_path, str), f\"output_dir_path must be a string, got {output_dir_path} (type {type(output_dir_path)})\"\n    if not os.path.exists(output_dir_path):\n        os.makedirs(output_dir_path, exist_ok=True)\n    assert os.path.isdir(output_dir_path), f\"After creation, output_dir_path {output_dir_path} is not a directory.\"\n\n\ndef run_shell_command(cmd: str) -> tuple:\n    \"\"\"Run a shell command and return a tuple (exit_code, std_output, std_error).\"\"\"\n    assert isinstance(cmd, str), f\"Command must be a string, got {cmd} (type {type(cmd)})\"\n    # Placeholder implementation\n    exit_code = 0\n    std_output = \"\"\n    std_error = \"\"\n    assert isinstance(exit_code, int), f\"exit_code must be int, got {exit_code} (type {type(exit_code)}) for command {cmd}\"\n    assert isinstance(std_output, str), f\"std_output must be string, got {std_output} (type {type(std_output)}) for command {cmd}\"\n    assert isinstance(std_error, str), f\"std_error must be string, got {std_error} (type {type(std_error)}) for command {cmd}\"\n    return exit_code, std_output, std_error\n\n\ndef write_output_text(output_file_path: str, output_text: str) -> None:\n    \"\"\"Write the output text to a file at output_file_path.\"\"\"\n    assert isinstance(output_file_path, str), f\"output_file_path must be a string, got {output_file_path} (type {type(output_file_path)})\"\n    assert isinstance(output_text, str), f\"output_text must be a string, got {output_text} (type {type(output_text)})\"\n    # Placeholder implementation for writing to file\n    with open(output_file_path, 'w') as f:\n        f.write(output_text)\n    # After writing, verify file exists\n    assert os.path.exists(output_file_path), f\"File {output_file_path} was not created after writing.\"\n\n\ndef task_func(commands_file_path: str, output_dir_path: str) -> list:\n    \"\"\"\n    Execute a list of shell commands read from a CSV file and save the outputs in separate files.\n    Each command's output is written to a unique file in the specified output directory.\n    If a command fails, the error message along with the exit code is appended to the respective output file.\n    Parameters:\n    - commands_file_path (str): Path to the CSV file containing shell commands in the first column.\n                                The file should not have headers.\n    - output_dir_path (str): Path where the outputs of the commands will be saved. If the directory does not exist,\n                             it will be created.\n    Returns:\n    - list of str: A list of paths to the output files created in the output directory, each named as\n                   'command_X_output.txt', where X is the command index.\n    \"\"\"\n    assert isinstance(commands_file_path, str) and commands_file_path, f\"commands_file_path must be a non-empty string, got {commands_file_path}\"\n    assert isinstance(output_dir_path, str) and output_dir_path, f\"output_dir_path must be a non-empty string, got {output_dir_path}\"\n    commands = read_commands_from_csv(commands_file_path)\n    assert isinstance(commands, list), f\"Expected commands to be a list; got {type(commands)} with value {commands}\"\n    for i, command in enumerate(commands):\n        assert isinstance(command, str), f\"Command at index {i} is not a string: {command} (type {type(command)})\"\n    ensure_directory_exists(output_dir_path)\n    output_file_paths = []\n    for idx, cmd in enumerate(commands, start=1):\n        assert isinstance(cmd, str) and cmd, f\"Command at index {idx} must be a non-empty string, got {cmd}\"\n        exit_code, std_output, std_error = run_shell_command(cmd)\n        assert isinstance(exit_code, int), f\"exit_code for command index {idx} must be int, got {exit_code} (type {type(exit_code)})\"\n        assert isinstance(std_output, str), f\"std_output for command index {idx} must be a string, got {std_output} (type {type(std_output)})\"\n        assert isinstance(std_error, str), f\"std_error for command index {idx} must be a string, got {std_error} (type {type(std_error)})\"\n        output_text = std_output if exit_code == 0 else f\"Error: {std_error}\\nExit Code: {exit_code}\"\n        assert isinstance(output_text, str), f\"output_text must be a string, got {output_text} (type {type(output_text)}) for command index {idx}\"\n        output_file_path = os.path.join(output_dir_path, f\"command_{idx}_output.txt\")\n        assert isinstance(output_file_path, str) and output_file_path, f\"Generated output_file_path must be a non-empty string, got {output_file_path}\"\n        write_output_text(output_file_path, output_text)\n        output_file_paths.append(output_file_path)\n        assert len(output_file_paths) == idx, f\"Loop invariant failed: expected {idx} output files, got {len(output_file_paths)}\"\n    assert isinstance(output_file_paths, list), f\"Final output_file_paths must be a list, got {type(output_file_paths)} with value {output_file_paths}\"\n    assert len(output_file_paths) == len(commands), f\"Number of output files {len(output_file_paths)} does not match number of commands {len(commands)}\"\n    for idx, path in enumerate(output_file_paths, start=1):\n        expected_name = os.path.join(output_dir_path, f\"command_{idx}_output.txt\")\n        assert isinstance(path, str), f\"Output file path at index {idx} must be a string, got {path} (type {type(path)})\"\n        # Optionally check naming pattern\n        assert expected_name == path, f\"Output file path mismatch: expected {expected_name}, got {path}\"\n    return output_file_paths\n\n\nimport csv\n\ndef read_commands_from_csv(file_path: str) -> list[str]:\n    \"\"\"\n    Read commands from a CSV file and return them as a list of strings.\n\n    Parameters:\n    - file_path (str): The path to the CSV file with commands in the first column.\n\n    Returns:\n    - list[str]: A list containing each command from the CSV file.\n    \"\"\"\n    assert isinstance(file_path, str), f\"file_path must be a string, got {type(file_path)}\"\n    commands = []\n    with open(file_path, 'r', newline='') as csvfile:\n        reader = csv.reader(csvfile)\n        for row in reader:\n            # Loop invariant: row must be a list\n            assert isinstance(row, list), f\"Each row must be a list, got {type(row)} in row {row}\"\n            if row:\n                # Row invariant: first element should be a string\n                assert isinstance(row[0], str), f\"First element of row must be a string, got {type(row[0])} in row {row}\"\n                commands.append(row[0])\n                # Loop invariant: commands list elements are expected to be strings\n                for cmd in commands:\n                    assert isinstance(cmd, str), f\"Command must be a string, got {type(cmd)} in command list {commands}\"\n    # Post-condition: commands must be a list of strings\n    assert isinstance(commands, list), f\"Output must be a list, got {type(commands)}\"\n    for cmd in commands:\n        assert isinstance(cmd, str), f\"Each command in output must be a string, got {type(cmd)} in command {cmd}\"\n    return commands\n\n\nimport os\n\ndef ensure_directory_exists(dir_path: str) -> None:\n    \"\"\"\n    Ensure that the given directory path exists. If it does not exist, create it.\n\n    Parameters:\n    - dir_path (str): The path of the directory to ensure.\n\n    Returns:\n    - None\n    \"\"\"\n    assert isinstance(dir_path, str), f\"Input error: dir_path must be a string, got {type(dir_path)}\"\n    if not os.path.isdir(dir_path):\n        os.makedirs(dir_path, exist_ok=True)\n    assert os.path.isdir(dir_path), f\"Post-condition error: Directory '{dir_path}' does not exist after processing.\"\n\n\nimport subprocess\n\ndef run_shell_command(command: str) -> tuple[int, str, str]:\n    \"\"\"\n    Run a shell command and capture its exit code, stdout, and stderr.\n\n    Parameters:\n    - command (str): The shell command to be executed.\n\n    Returns:\n    - tuple[int, str, str]: A tuple containing the exit code, standard output, and standard error.\n    \"\"\"\n    assert isinstance(command, str), f\"Expected command as string, got {type(command)} with value: {command}\"\n    try:\n        result = subprocess.run(command, shell=True, capture_output=True, text=True)\n    except Exception as e:\n        ret = (1, \"\", str(e))\n        assert isinstance(ret, tuple) and len(ret) == 3, f\"Return value should be a tuple of length 3, got {ret}\"\n        assert isinstance(ret[0], int) and isinstance(ret[1], str) and isinstance(ret[2], str), f\"Return tuple types incorrect: got types {type(ret[0])}, {type(ret[1])}, {type(ret[2])}\"\n        return ret\n    ret = (result.returncode, result.stdout, result.stderr)\n    assert isinstance(ret, tuple) and len(ret) == 3, f\"Return value should be a tuple of length 3; got tuple of length {len(ret)} with value {ret}\"\n    assert isinstance(ret[0], int) and isinstance(ret[1], str) and isinstance(ret[2], str), f\"Return tuple types are not correct: got types {type(ret[0])}, {type(ret[1])}, {type(ret[2])}\"\n    return ret\n\ndef write_output_text(file_path: str, content: str) -> None:\n    \"\"\"\n    Write the given content to the specified file path.\n\n    Parameters:\n    - file_path (str): The path to the output file.\n    - content (str): The text content to be written.\n\n    Returns:\n    - None\n    \"\"\"\n    assert isinstance(file_path, str), f\"file_path must be a string, got {type(file_path)} with value {file_path}\"\n    assert isinstance(content, str), f\"content must be a string, got {type(content)} with value {content}\"\n    try:\n        with open(file_path, 'w', encoding='utf-8') as file:\n            file.write(content)\n    except Exception as e:\n        raise e\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            read_content = file.read()\n    except Exception as e:\n        raise AssertionError(f\"Unable to read the file {file_path} after writing. Error: {e}\")\n    assert read_content == content, f\"After writing, the content in '{file_path}' is '{read_content}' but expected '{content}'.\"", "testing": false, "error_message": "F.....\n======================================================================\nFAIL: test_command_failure_with_specific_exit_code (__test__.TestCases.test_command_failure_with_specific_exit_code)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 329, in test_command_failure_with_specific_exit_code\n    self.assertIn(\"Error executing command\", content)\n    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Error executing command' not found in 'Error: \\nExit Code: 1'\n\n----------------------------------------------------------------------\nRan 6 tests in 0.070s\n\nFAILED (failures=1)\n"}, "3": {"task_id": "BigCodeBench/17", "function_name": "task_func", "code": "import psutil\nimport subprocess\nimport time\n\ndef task_func(process_name: str) -> str:\n    \"\"\"\n    Check if a particular process is running based on its name. If it is not running, start it using the process name as a command.\n    If it is running, terminate the process and restart it by executing the process name as a command.\n\n    Parameters:\n    - process_name (str): The name of the process to check and manage. This should be executable as a command.\n\n    Returns:\n    - str: A message indicating the action taken:\n        - \"Process not found. Starting <process_name>.\"\n        - \"Process found. Restarting <process_name>.\"\n    \"\"\"\n    \n    assert isinstance(process_name, str), f\"Invalid input: process_name must be a string, got {type(process_name)}\"\n    \n    matching_processes = []\n    for proc in psutil.process_iter(['name']):\n        try:\n            proc_name = proc.info.get('name', '')\n            assert isinstance(proc_name, str), f\"Process name should be string, got {type(proc_name)} for process {proc}\"\n            if proc_name.lower() == process_name.lower():\n                matching_processes.append(proc)\n        except (psutil.NoSuchProcess, psutil.AccessDenied) as e:\n            continue\n    \n    if not matching_processes:\n        try:\n            p = subprocess.Popen([process_name])\n            time.sleep(1)  \n        except Exception as e:\n            assert False, f\"Failed to start process {process_name}: {e}\"\n        result = f\"Process not found. Starting {process_name}.\"\n    else:\n        for proc in matching_processes:\n            try:\n                proc.terminate()\n                proc.wait(timeout=5)\n            except Exception as e:\n                assert False, f\"Failed to terminate process {process_name} (pid: {proc.pid}): {e}\"\n        try:\n            p = subprocess.Popen([process_name])\n            time.sleep(1) \n        except Exception as e:\n            assert False, f\"Failed to restart process {process_name}: {e}\"\n        result = f\"Process found. Restarting {process_name}.\"\n    \n    allowed_outputs = {f\"Process not found. Starting {process_name}.\", f\"Process found. Restarting {process_name}.\"}\n    assert result in allowed_outputs, f\"Output did not match expected messages. Got: {result}, allowed: {allowed_outputs}\"\n    return result\n\n\ndef check_process_running(process_name: str) -> bool:\n    '''\n    Check if a given process is running.\n\n    Parameters:\n    - process_name (str): The name of the process to check.\n\n    Returns:\n    - bool: True if the process is found running, False otherwise.\n    '''\n    assert isinstance(process_name, str), f\"process_name must be a string, got {type(process_name)}\"\n    assert len(process_name) > 0, f\"process_name must not be empty, got length {len(process_name)}\"\n    import psutil\n    result = False\n    for proc in psutil.process_iter(['name']):\n        # Loop invariant: proc.info should be a dict\n        info = proc.info\n        assert isinstance(info, dict), f\"Expected proc.info to be a dict, got {type(info)} for proc {proc}\"\n        try:\n            proc_name = info.get('name', '')\n            # Loop invariant: proc_name should be a string or None\n            assert proc_name is None or isinstance(proc_name, str), f\"Expected process name to be a string or None, got {type(proc_name)} with info {info}\"\n            if proc_name and proc_name.lower() == process_name.lower():\n                result = True\n                break\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as exc:\n            continue\n    assert isinstance(result, bool), f\"Final result must be boolean, got {type(result)} with value {result}\"\n    return result\n\n\ndef kill_process(process_name: str) -> None:\n    \"\"\"\n    Kill all instances of a given process by name, if running.\n\n    Parameters:\n    - process_name (str): The name of the process to kill.\n\n    Returns:\n    - None\n    \"\"\"\n    assert isinstance(process_name, str), f\"Input error: process_name ({process_name}) is not a string\"\n    assert len(process_name) > 0, f\"Input error: process_name must not be empty, got '{process_name}'\"\n\n    import psutil\n    \n    killed_count = 0\n    \n    for proc in psutil.process_iter(['name']):\n        assert hasattr(proc, 'kill'), f\"Loop invariant error: proc object {proc} lacks a kill method\"\n        assert isinstance(proc.info, dict), f\"Loop invariant error: proc.info ({proc.info}) is not a dict\"\n        \n        try:\n            proc_name = proc.info['name']\n            assert (proc_name is None or isinstance(proc_name, str)), f\"Invariant error: proc_name ({proc_name}) must be None or a string\"\n            \n            if proc_name and proc_name.lower() == process_name.lower():\n                proc.kill()\n                killed_count += 1\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:\n            continue\n    \n    assert isinstance(killed_count, int) and killed_count >= 0, f\"Invariant error: killed_count ({killed_count}) must be a non-negative integer\"\n    \n    result = None\n    assert result is None, f\"Output error: function return value is not None, got {result}\"\n    return\n\nimport subprocess\n\ndef start_process(process_name: str) -> None:\n    \"\"\"\n    Start a process by its name/command.\n\n    Parameters:\n    - process_name (str): The command to start a new process.\n\n    Returns:\n    - None\n    \"\"\"\n    assert isinstance(process_name, str), f\"Input error: process_name must be a string, got {type(process_name)}\"\n    assert len(process_name) > 0, f\"Input error: process_name must not be empty, got '{process_name}'\"\n    \n    try:\n        proc = subprocess.Popen(process_name, shell=True)\n    except Exception as e:\n        raise e\n    \n    assert hasattr(proc, 'pid'), f\"Post-condition error: The process handle does not have a 'pid' attribute for command '{process_name}'\"\n    assert isinstance(proc.pid, int), f\"Post-condition error: The process PID is not an integer for command '{process_name}', got {proc.pid}\"\n    \n    return None", "testing": false, "error_message": "FFF\n======================================================================\nFAIL: test_process_found_restarts_process (__test__.TestCases.test_process_found_restarts_process)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 216, in test_process_found_restarts_process\n    result = task_func('notepad')\n  File \"/tmp/testing_python_program.py\", line 72, in task_func\n    assert isinstance(proc_name, str), f\"Process name should be string, got {type(proc_name)} for process {proc}\"\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^\nAssertionError: Process name should be string, got <class 'unittest.mock.MagicMock'> for process <MagicMock id='4379850608'>\n\n======================================================================\nFAIL: test_process_not_found_starts_process (__test__.TestCases.test_process_not_found_starts_process)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 208, in test_process_not_found_starts_process\n    mock_popen.assert_called_once_with('random_non_existent_process')\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 989, in assert_called_once_with\n    return self.assert_called_with(*args, **kwargs)\n           ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 977, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: Popen('random_non_existent_process')\n  Actual: Popen(['random_non_existent_process'])\n\n======================================================================\nFAIL: test_process_terminates_and_restarts_multiple_instances (__test__.TestCases.test_process_terminates_and_restarts_multiple_instances)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 230, in test_process_terminates_and_restarts_multiple_instances\n    result = task_func('multi_instance')\n  File \"/tmp/testing_python_program.py\", line 72, in task_func\n    assert isinstance(proc_name, str), f\"Process name should be string, got {type(proc_name)} for process {proc}\"\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^\nAssertionError: Process name should be string, got <class 'unittest.mock.MagicMock'> for process <MagicMock id='4379850608'>\n\n----------------------------------------------------------------------\nRan 3 tests in 1.011s\n\nFAILED (failures=3)\n"}}}