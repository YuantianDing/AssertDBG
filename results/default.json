{"_default": {"1": {"task_id": "BigCodeBench/13", "function_name": "task_func", "code": "def task_func(ftp_server: str = 'ftp.dlptest.com', ftp_user: str = 'dlpuser', ftp_password: str = 'rNrKYTX9g7z3RgJRmxWuGHbeu', ftp_dir: str = '/ftp/test') -> list[str]:\n    # Input assertions\n    assert isinstance(ftp_server, str), f\"ftp_server must be a string. Got: {ftp_server} of type {type(ftp_server)}\"\n    assert isinstance(ftp_user, str), f\"ftp_user must be a string. Got: {ftp_user} of type {type(ftp_user)}\"\n    assert isinstance(ftp_password, str), f\"ftp_password must be a string. Got: {ftp_password} of type {type(ftp_password)}\"\n    assert isinstance(ftp_dir, str), f\"ftp_dir must be a string. Got: {ftp_dir} of type {type(ftp_dir)}\"\n\n    # Connect to the FTP server\n    ftp = connect_ftp(ftp_server, ftp_user, ftp_password)\n    # Assert that ftp connection is established\n    assert ftp is not None, f\"FTP connection failed: ftp is None. ftp_server: {ftp_server}\"\n\n    # Change the current directory on the FTP server\n    change_directory(ftp, ftp_dir)\n    # Optionally, if there is a way to check current directory, add an assertion here\n\n    # Retrieve the list of files\n    files = list_files(ftp)\n    assert isinstance(files, list), f\"files must be a list, got {files} of type {type(files)}\"\n\n    # Attempt to download each file\n    for filename in files:\n        assert isinstance(filename, str), f\"Each filename must be a string. Got: {filename} of type {type(filename)}\"\n        download_file(filename, ftp_server, ftp_user, ftp_password, ftp_dir)\n\n    # Output assertion: all items in files must be strings\n    assert all(isinstance(f, str) for f in files), f\"Not all items in files are strings: {files}\"\n\n    return files\n\nimport ftplib\n\ndef connect_ftp(ftp_server: str, ftp_user: str, ftp_password: str) -> ftplib.FTP:\n    # Ensure input types are correct\n    assert isinstance(ftp_server, str), f\"ftp_server must be a string, got {type(ftp_server)}\"\n    assert isinstance(ftp_user, str), f\"ftp_user must be a string, got {type(ftp_user)}\"\n    assert isinstance(ftp_password, str), f\"ftp_password must be a string, got {type(ftp_password)}\"\n    \n    # Optionally check that the server and user are not empty\n    assert ftp_server != '', \"ftp_server cannot be an empty string\"\n    assert ftp_user != '', \"ftp_user cannot be an empty string\"\n\n    try:\n        ftp = ftplib.FTP(ftp_server)\n        # Assert that the connection object has been created and socket is not None after instantiation\n        assert ftp is not None, \"Failed to create FTP object for server: {}\".format(ftp_server)\n        \n        # Log in using the provided credentials\n        ftp.login(ftp_user, ftp_password)\n        \n        # Assert that after login, the connection seems active (ftp.sock should not be None)\n        assert ftp.sock is not None, f\"FTP connection socket is None after login for server {ftp_server}\"\n    except Exception as e:\n        raise Exception(f\"Unable to connect or log in to the FTP server {ftp_server} with user {ftp_user}.\") from e\n    \n    # Final assertion to ensure the output is of correct type\n    assert isinstance(ftp, ftplib.FTP), f\"Return value is not an instance of ftplib.FTP, got {type(ftp)}\"\n    return ftp\n\n\ndef change_directory(ftp: 'ftplib.FTP', ftp_dir: str) -> None:\n    import ftplib\n    \n    # Input Assertions\n    assert isinstance(ftp, ftplib.FTP), f\"Expected ftp to be instance of ftplib.FTP, got {type(ftp)} with value {ftp}\"\n    assert isinstance(ftp_dir, str), f\"Expected ftp_dir to be a string, got {type(ftp_dir)} with value {ftp_dir}\"\n    \n    # Save current directory for later verification if needed (not used here) \n    try:\n        ftp.cwd(ftp_dir)\n    except Exception as e:\n        raise Exception(f\"Failed to change directory to {ftp_dir}: {e}\")\n    \n    # Post-condition: verify that the FTP's current directory is now ftp_dir\n    try:\n        current_dir = ftp.pwd()\n    except Exception as e:\n        raise Exception(f\"Unable to retrieve current directory after change: {e}\")\n    \n    assert current_dir == ftp_dir, f\"Expected current directory to be '{ftp_dir}', but got '{current_dir}'\"\n\n\n\ndef list_files(ftp: 'ftplib.FTP') -> list[str]:\n    import ftplib\n    # Input assertion\n    assert isinstance(ftp, ftplib.FTP), f\"[list_files] Provided ftp object is not an instance of ftplib.FTP, got type {type(ftp)}\"\n    \n    # Call the nlst method on the ftp object to get the list of files\n    file_list = ftp.nlst()\n    \n    # Assert that the result from nlst is a list\n    assert isinstance(file_list, list), f\"[list_files] Expected file_list to be a list, but got type {type(file_list)}\"\n    \n    # Loop invariant: each element in the list should be of type str\n    for idx, file in enumerate(file_list):\n        assert isinstance(file, str), f\"[list_files] Expected element at index {idx} to be a str, but got type {type(file)} with value {file}\"\n    \n    # Final output assertion: ensure file_list is a list of strings\n    assert all(isinstance(item, str) for item in file_list), f\"[list_files] Final output validation failed. file_list: {file_list}\"\n    \n    return file_list\n\nimport subprocess\nimport os\n\ndef download_file(filename: str, ftp_server: str, ftp_user: str, ftp_password: str, ftp_dir: str) -> None:\n    # Input Assertions\n    assert isinstance(filename, str), f\"Expected filename as str, got {type(filename)} for filename={filename}\"\n    assert isinstance(ftp_server, str), f\"Expected ftp_server as str, got {type(ftp_server)} for ftp_server={ftp_server}\"\n    assert isinstance(ftp_user, str), f\"Expected ftp_user as str, got {type(ftp_user)} for ftp_user={ftp_user}\"\n    assert isinstance(ftp_password, str), f\"Expected ftp_password as str, got {type(ftp_password)} for ftp_password=****\"\n    assert isinstance(ftp_dir, str), f\"Expected ftp_dir as str, got {type(ftp_dir)} for ftp_dir={ftp_dir}\"\n\n    # Clean up ftp_dir to avoid leading slash\n    ftp_dir_clean = ftp_dir.lstrip('/')\n    assert ftp_dir_clean is not None, f\"ftp_dir_clean should not be None for original ftp_dir={ftp_dir}\"\n\n    url = f\"ftp://{ftp_server}/{ftp_dir_clean}/{filename}\"\n    assert url.startswith('ftp://'), f\"URL {url} is malformed; expected to start with 'ftp://'\"\n\n    # Construct wget command\n    cmd = [\n        \"wget\",\n        f\"--ftp-user={ftp_user}\",\n        f\"--ftp-password={ftp_password}\",\n        url\n    ]\n    assert len(cmd) == 4, f\"Command list length should be 4, got {len(cmd)}; cmd={cmd}\"\n\n    # Execute the command\n    try:\n        result = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n        # Assert that stdout or stderr is returned as string (in case needed for debugging)\n        assert isinstance(result.stdout, str), f\"Expected stdout to be str, got {type(result.stdout)}\"\n        assert isinstance(result.stderr, str), f\"Expected stderr to be str, got {type(result.stderr)}\"\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Failed to download file {filename} from FTP server {ftp_server} at directory {ftp_dir}. Error: {e}\")\n\n    # Final Output Assertion: Verify that file exists after download\n    file_exists = os.path.isfile(filename)\n    assert file_exists, f\"Download completed but file '{filename}' does not exist. Check command output and permissions.\"\n\nif __name__ == \"__main__\":\n    # Example test parameters (replace with actual FTP details for a real test)\n    test_filename = \"example.txt\"\n    test_ftp_server = \"ftp.example.com\"\n    test_ftp_user = \"user\"\n    test_ftp_password = \"password\"\n    test_ftp_dir = \"pub/files\"\n\n    try:\n        download_file(test_filename, test_ftp_server, test_ftp_user, test_ftp_password, test_ftp_dir)\n        print(f\"Downloaded {test_filename} successfully.\")\n    except Exception as err:\n        print(f\"An error occurred: {err}\")\n", "testing": false, "error_message": "EFFFF\n======================================================================\nERROR: test_case_1 (__test__.TestCases.test_case_1)\nTest with default parameters and successful download.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 247, in test_case_1\n    downloaded_files = task_func()\n  File \"/tmp/testing_python_program.py\", line 76, in task_func\n    ftp = connect_ftp(ftp_server, ftp_user, ftp_password)\n  File \"/tmp/testing_python_program.py\", line 124, in connect_ftp\n    assert isinstance(ftp, ftplib.FTP), f\"Return value is not an instance of ftplib.FTP, got {type(ftp)}\"\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^^\nTypeError: isinstance() arg 2 must be a type, a tuple of types, or a union\n\n======================================================================\nFAIL: test_case_2 (__test__.TestCases.test_case_2)\nTest with an invalid FTP server by raising an exception on connect.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 258, in test_case_2\n    self.assertEqual(str(context.exception), f'Failed to connect to FTP server invalid_server: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Unable to connect or log in to the FTP se[34 chars]ser.' != 'Failed to connect to FTP server invalid_s[34 chars]rver'\n- Unable to connect or log in to the FTP server invalid_server with user dlpuser.\n+ Failed to connect to FTP server invalid_server: Failed to connect to FTP server\n\n\n======================================================================\nFAIL: test_case_3 (__test__.TestCases.test_case_3)\nTest with an invalid FTP user by raising an exception on login.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 266, in test_case_3\n    self.assertEqual(str(context.exception), f'Failed to log into FTP server ftp.dlptest.com with user invalid_user: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Unable to connect or log in to the FTP se[40 chars]ser.' != 'Failed to log into FTP server ftp.dlptest[40 chars]ogin'\n- Unable to connect or log in to the FTP server ftp.dlptest.com with user invalid_user.\n? ^^ ^     -----------       -  ----                                                  ^\n+ Failed to log into FTP server ftp.dlptest.com with user invalid_user: Failed to login\n? ^ ^  +                                                              ^^^^^^^^^^^^^^^^^\n\n\n======================================================================\nFAIL: test_case_4 (__test__.TestCases.test_case_4)\nTest with an invalid FTP password by raising an exception on login.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 274, in test_case_4\n    self.assertEqual(str(context.exception), f'Failed to log into FTP server ftp.dlptest.com with user dlpuser: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Unable to connect or log in to the FTP se[35 chars]ser.' != 'Failed to log into FTP server ftp.dlptest[35 chars]ogin'\n- Unable to connect or log in to the FTP server ftp.dlptest.com with user dlpuser.\n? ^^ ^     -----------       -  ----                                             ^\n+ Failed to log into FTP server ftp.dlptest.com with user dlpuser: Failed to login\n? ^ ^  +                                                         ^^^^^^^^^^^^^^^^^\n\n\n======================================================================\nFAIL: test_case_5 (__test__.TestCases.test_case_5)\nTest with an invalid FTP directory by raising an exception on cwd.\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 282, in test_case_5\n    self.assertEqual(str(context.exception), f'Failed to change to directory /invalid_directory on server ftp.dlptest.com: {error_message}')\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'isinstance() arg 2 must be a type, a tupl[18 chars]nion' != 'Failed to change to directory /invalid_di[57 chars]tory'\n- isinstance() arg 2 must be a type, a tuple of types, or a union\n+ Failed to change to directory /invalid_directory on server ftp.dlptest.com: Failed to change directory\n\n\n----------------------------------------------------------------------\nRan 5 tests in 0.012s\n\nFAILED (failures=4, errors=1)\n"}, "2": {"task_id": "BigCodeBench/15", "function_name": "task_func", "code": "import os\nimport csv\nimport subprocess\n\n\ndef read_commands_from_csv(commands_file_path: str) -> list:\n    # Dummy implementation placeholder\n    # This function should read the CSV file and return a list of commands (strings)\n    commands = []\n    with open(commands_file_path, newline='') as csvfile:\n        reader = csv.reader(csvfile)\n        for row in reader:\n            # Assuming first column is the command\n            if row:\n                commands.append(row[0])\n    # Assertion to ensure the commands are strings\n    for cmd in commands:\n        assert isinstance(cmd, str), f\"Expected command to be str but got {type(cmd)} for command: {cmd}\"\n    return commands\n\n\ndef ensure_output_dir(output_dir_path: str) -> None:\n    # Dummy implementation placeholder\n    if not os.path.exists(output_dir_path):\n        os.makedirs(output_dir_path)\n    # Assert directory now exists\n    assert os.path.isdir(output_dir_path), f\"Output directory {output_dir_path} was not created successfully.\"\n\n\ndef execute_command(cmd: str, index: int, output_dir_path: str) -> str:\n    # Dummy implementation placeholder\n    # This function executes the command and writes the output to a file named 'command_<index>_output.txt'\n    output_file = os.path.join(output_dir_path, f\"command_{index}_output.txt\")\n    try:\n        result = subprocess.run(cmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n        output = result.stdout\n    except subprocess.CalledProcessError as e:\n        output = f\"Command failed with exit code {e.returncode}. Error: {e.stderr}\"\n    with open(output_file, 'w') as f:\n        f.write(output)\n    # Assert file was written\n    assert os.path.isfile(output_file), f\"Output file {output_file} was not created for command index {index} with cmd: {cmd}\"\n    return output_file\n\n\ndef task_func(commands_file_path: str, output_dir_path: str) -> list[str]:\n    # Input type assertions\n    assert isinstance(commands_file_path, str), f\"Expected commands_file_path to be str but got {type(commands_file_path)}\"\n    assert isinstance(output_dir_path, str), f\"Expected output_dir_path to be str but got {type(output_dir_path)}\"\n    \n    # Assert the commands file exists\n    assert os.path.isfile(commands_file_path), f\"The commands file path does not exist: {commands_file_path}\"\n\n    commands = read_commands_from_csv(commands_file_path)\n    # Ensure commands is a non-empty list\n    assert isinstance(commands, list), f\"Expected a list of commands but got {type(commands)}\"\n    \n    ensure_output_dir(output_dir_path)\n    \n    output_files = []\n    num_commands = len(commands)\n    # Loop invariant: After each iteration, len(output_files) should equal the current command index\n    for index, cmd in enumerate(commands, start=1):\n        # Assert that the current command is a non-empty string\n        assert isinstance(cmd, str) and cmd.strip() != \"\", f\"Invalid command at index {index}: {cmd}\"\n        \n        output_file = execute_command(cmd, index, output_dir_path)\n        # Assert that the output_file is a non-empty string\n        assert isinstance(output_file, str) and output_file.strip() != \"\", f\"execute_command returned invalid output_file at index {index}: {output_file}\"\n        \n        output_files.append(output_file)\n        # Loop invariant check\n        assert len(output_files) == index, f\"Loop invariant failed: expected output_files length {index}, got {len(output_files)}\"\n\n    # Final assertions: Verify the output list length matches commands length and every file exists\n    assert len(output_files) == num_commands, f\"Expected {num_commands} output files, but got {len(output_files)}\"\n    for path in output_files:\n        assert os.path.isfile(path), f\"Expected output file does not exist: {path}\"\n\n    return output_files\n\n\nimport csv\n\n\ndef read_commands_from_csv(commands_file_path: str) -> list[str]:\n    \"\"\"\n    Read shell commands from a CSV file (without headers) and return them as a list of strings.\n\n    Parameters:\n    - commands_file_path (str): The path to the CSV file containing commands in the first column.\n\n    Returns:\n    - list[str]: A list of commands.\n    \"\"\"\n    # Input assertion\n    assert isinstance(commands_file_path, str), f\"commands_file_path must be a string, got {type(commands_file_path)}\"\n\n    commands = []\n    \n    # Open the CSV file\n    with open(commands_file_path, mode='r', newline='', encoding='utf-8') as csvfile:\n        reader = csv.reader(csvfile)\n        \n        # Loop through each row in the CSV file\n        for idx, row in enumerate(reader):\n            # Loop invariant: commands is a list and each element is a string\n            assert isinstance(commands, list), f\"At row {idx}, commands should be a list, got {type(commands)}\"\n            \n            # If row is not empty, it must have at least one column\n            if row:\n                assert len(row) >= 1, f\"Row {idx} is not empty but has no columns: {row}\"\n                # Assert that the first column is a string\n                assert isinstance(row[0], str), f\"Row {idx} first column must be a string, got {type(row[0])} in row {row}\"\n                commands.append(row[0])\n\n    # Output assertion: the function must return a list\n    assert isinstance(commands, list), f\"Output commands must be a list, got {type(commands)}\"\n    # Further, each element in the commands list should be a string\n    for i, cmd in enumerate(commands):\n        assert isinstance(cmd, str), f\"Element {i} in output is not a string: {cmd} (type: {type(cmd)})\"\n\n    return commands\n\nimport os\n\ndef ensure_output_dir(output_dir_path: str) -> None:\n    assert isinstance(output_dir_path, str), f\"Invalid type for output_dir_path: {type(output_dir_path).__name__}. Expected str.\"\n    if not os.path.exists(output_dir_path):\n        os.makedirs(output_dir_path)\n        assert os.path.exists(output_dir_path), f\"Failed to create directory: {output_dir_path}\"\n    assert os.path.isdir(output_dir_path), f\"The path exists but is not a directory: {output_dir_path}\"\n    return\n\n\nimport os\nimport subprocess\n\ndef execute_command(command: str, command_index: int, output_dir_path: str) -> str:\n    # Assert that inputs are of the correct type\n    assert isinstance(command, str), f\"Expected command to be str, got {type(command)}\"\n    assert isinstance(command_index, int), f\"Expected command_index to be int, got {type(command_index)}\"\n    assert isinstance(output_dir_path, str), f\"Expected output_dir_path to be str, got {type(output_dir_path)}\"\n\n    # Ensure that the output directory exists, if not, create it\n    if not os.path.exists(output_dir_path):\n        try:\n            os.makedirs(output_dir_path)\n        except Exception as e:\n            assert False, f\"Failed to create directory {output_dir_path}: {e}\"\n    else:\n        assert os.path.isdir(output_dir_path), f\"The path {output_dir_path} exists but is not a directory\"\n\n    # Construct the output filename using the command index\n    output_file_name = f\"command_output_{command_index}.txt\"\n    output_file_path = os.path.join(output_dir_path, output_file_name)\n\n    try:\n        # Execute the command using subprocess. Using shell=True to allow shell commands.\n        result = subprocess.run(command, shell=True, capture_output=True, text=True)\n        # Check the process result: result.returncode should be an integer\n        assert isinstance(result.returncode, int), f\"Expected result.returncode to be int, got {type(result.returncode)}\"\n        \n        # If the command executed successfully (return code 0), use stdout, otherwise use stderr\n        if result.returncode == 0:\n            output = result.stdout\n        else:\n            output = result.stderr\n    except Exception as e:\n        # If an exception occurs during command execution, capture it\n        output = str(e)\n    \n    # Write the command output or error information to the file\n    try:\n        with open(output_file_path, 'w', encoding='utf-8') as file:\n            file.write(output)\n    except Exception as e:\n        assert False, f\"Failed to write output to file {output_file_path}: {e}\"\n    \n    # Assert that the output file has been created\n    assert os.path.exists(output_file_path), f\"Output file {output_file_path} was not created as expected.\"\n    \n    # Final post condition: The file should be non-empty if there was any output generated\n    file_size = os.path.getsize(output_file_path)\n    assert file_size >= 0, f\"Output file size should be >= 0, got {file_size}\"\n    \n    return output_file_path", "testing": false, "error_message": "F.F...\n======================================================================\nFAIL: test_command_failure_with_specific_exit_code (__test__.TestCases.test_command_failure_with_specific_exit_code)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 323, in test_command_failure_with_specific_exit_code\n    self.assertIn(\"Error executing command\", content)\n    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Error executing command' not found in ''\n\n======================================================================\nFAIL: test_file_not_found (__test__.TestCases.test_file_not_found)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 278, in test_file_not_found\n    task_func(os.path.join(self.temp_dir, \"nonexistent.csv\"), self.output_dir_path)\n    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/testing_python_program.py\", line 112, in task_func\n    assert os.path.isfile(commands_file_path), f\"The commands file path does not exist: {commands_file_path}\"\n           ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^\nAssertionError: The commands file path does not exist: /var/folders/s1/lbpq1cq546z6qd12zd_zl6cm0000gn/T/tmpippmhu13/nonexistent.csv\n\n----------------------------------------------------------------------\nRan 6 tests in 0.067s\n\nFAILED (failures=2)\n"}, "3": {"task_id": "BigCodeBench/17", "function_name": "task_func", "code": "def task_func(process_name: str) -> str:\n    # Assert that the input process_name is a non-empty string\n    assert isinstance(process_name, str), f\"task_func: process_name must be of type str, got {process_name} with type {type(process_name)}\"\n    assert process_name, f\"task_func: process_name cannot be empty, got '{process_name}'\"\n\n    # Retrieve processes matching the name\n    processes = get_processes_by_name(process_name)\n    assert isinstance(processes, list), f\"task_func: Expected get_processes_by_name to return a list, got {processes} with type {type(processes)}\"\n\n    # Depending on whether processes exist, start or restart the process\n    if not processes:\n        start_process(process_name)\n        result = f\"Process not found. Starting {process_name}.\"\n    else:\n        kill_processes(processes)\n        start_process(process_name)\n        result = f\"Process found. Restarting {process_name}.\"\n\n    # Final output assertion\n    expected1 = f\"Process not found. Starting {process_name}.\"\n    expected2 = f\"Process found. Restarting {process_name}.\"\n    assert result in [expected1, expected2], f\"task_func: Unexpected return value: {result}. Expected one of: {expected1} or {expected2}\"\n    return result\n\ndef get_processes_by_name(process_name: str):\n    \"\"\"\n    Retrieve a list of processes that match the given process_name.\n    \"\"\"\n    assert isinstance(process_name, str), f\"get_processes_by_name: process_name must be str, got {process_name} with type {type(process_name)}\"\n    # Stub implementation: In a realistic scenario, this would use psutil and filtering.\n    result = []\n    assert isinstance(result, list), f\"get_processes_by_name: Return value must be a list, got {result} with type {type(result)}\"\n    return result\n\n\ndef start_process(process_name: str):\n    \"\"\"\n    Start a process using the given process_name as the command.\n    \"\"\"\n    assert isinstance(process_name, str), f\"start_process: process_name must be str, got {process_name} with type {type(process_name)}\"\n    # Stub implementation: In a realistic scenario, this would use subprocess to start the process.\n    pass\n\n\ndef kill_processes(processes):\n    \"\"\"\n    Kill all processes provided in the processes list.\n    \"\"\"\n    assert isinstance(processes, list), f\"kill_processes: processes must be a list, got {processes} with type {type(processes)}\"\n    # Stub implementation: In a realistic scenario, this would iterate over processes and kill them.\n    pass\n\nimport psutil\n\ndef get_processes_by_name(process_name: str) -> list:\n    # Input assertion: ensure process_name is a string\n    assert isinstance(process_name, str), f\"Input 'process_name' must be a string, got {type(process_name)}\"\n    \n    found_processes = []\n    \n    # Iterate over all running processes using psutil.process_iter with attribute 'name'\n    for proc in psutil.process_iter(['name']):\n        try:\n            proc_name = proc.info.get('name', '')\n            # Assert that proc_name is a string\n            assert isinstance(proc_name, str), f\"Process name should be a string, got {type(proc_name)} for PID {getattr(proc, 'pid', 'Unknown')}\"\n            \n            # Condition to check if process_name is a substring of proc_name\n            if process_name in proc_name:\n                found_processes.append(proc)\n            \n            # Loop invariant: all processes in found_processes must be instances of psutil.Process\n            for p in found_processes:\n                assert isinstance(p, psutil.Process), f\"Element in found_processes is not a psutil.Process: {p}\"\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:\n            # Skip processes that raise exceptions\n            continue\n    \n    # Output assertion: ensure that found_processes is indeed a list\n    assert isinstance(found_processes, list), f\"Output must be a list, got {type(found_processes)}\"\n    \n    # Final invariant: each process in found_processes should have a 'pid' attribute\n    for p in found_processes:\n        assert hasattr(p, 'pid'), f\"Process object {p} missing 'pid' attribute\"\n\n    return found_processes\n\ndef kill_processes(processes: list) -> None:\n    '''\n    Terminate all given processes.\n\n    Parameters:\n    - processes (list): A list of processes (objects with 'terminate' and 'wait' methods) to be terminated.\n\n    Returns:\n    - None\n    '''\n    # Assert that the input is a list\n    assert isinstance(processes, list), f\"Input 'processes' must be a list, got {type(processes).__name__}.\"\n\n    # Assert that each process in the list implements 'terminate' and 'wait'\n    for idx, proc in enumerate(processes):\n        assert hasattr(proc, 'terminate'), f\"Process at index {idx} does not have a 'terminate' method: {proc}\"\n        assert hasattr(proc, 'wait'), f\"Process at index {idx} does not have a 'wait' method: {proc}\"\n\n    # Iterate over each process in the list and attempt to terminate it\n    for idx, proc in enumerate(processes):\n        try:\n            proc.terminate()  \n            # Optionally, wait for the process to actually terminate\n            proc.wait(timeout=3) \n        except Exception as e:\n            print(f\"Failed to terminate process at index {idx} ({proc}): {e}\")\n\n    # Post-condition: Assert that each process has been terminated, if possible to check termination status.\n    for idx, proc in enumerate(processes):\n        # Check if the process provides an 'is_running' method\n        if hasattr(proc, 'is_running'):\n            assert not proc.is_running(), f\"Process at index {idx} is still running: {proc}\"\n        # Alternatively, if it wraps a subprocess.Popen object, check its poll() method\n        elif hasattr(proc, 'popen') and hasattr(proc.popen, 'poll'):\n            ret = proc.popen.poll()\n            assert ret is not None, f\"Process at index {idx} (pid {proc.popen.pid}) is still running, poll returned None.\"\n        # If no standard way to check termination, then we skip the check\n    \nif __name__ == '__main__':\n    import subprocess\n    import time\n\n    # Create two dummy processes using the subprocess module\n    process1 = subprocess.Popen(['sleep', '10'])\n    process2 = subprocess.Popen(['sleep', '10'])\n\n    # Create a simple wrapper class around the subprocess.Popen object.\n    class DummyProcessWrapper:\n        def __init__(self, popen_obj):\n            self.popen = popen_obj\n        def terminate(self):\n            self.popen.terminate()\n        def wait(self, timeout=None):\n            return self.popen.wait(timeout=timeout)\n        def __str__(self):\n            return f\"DummyProcessWrapper(pid={self.popen.pid})\"\n        # Optional: add an is_running method\n        def is_running(self):\n            return self.popen.poll() is None\n\n    # Wrap the processes\n    processes = [DummyProcessWrapper(process1), DummyProcessWrapper(process2)]\n\n    # Use the kill_processes function to terminate the processes\n    kill_processes(processes)\n\n    # Verify the processes have been terminated\n    for proc in processes:\n        retcode = proc.popen.poll()\n        print(f\"Process {proc.popen.pid} terminated with exit code: {retcode}\")\n\nimport subprocess\n\ndef start_process(process_name: str) -> None:\n    # Assert that the input is a string\n    assert isinstance(process_name, str), f\"Input 'process_name' must be a string, got type {type(process_name)}.\"\n    \n    # Initialize process handle variable for loop invariants and output check\n    process_handle = None\n    \n    try:\n        # Start the process using subprocess.Popen\n        process_handle = subprocess.Popen(process_name, shell=True)\n        # Assert that the returned process_handle has a PID attribute if command is non-empty\n        if process_name.strip() != '':\n            assert hasattr(process_handle, 'pid'), f\"Process handle for command '{process_name}' does not have a 'pid' attribute.\"\n    except Exception as e:\n        # In case of exception, process_handle should remain None\n        process_handle = None\n        print(f\"Failed to start process '{process_name}': {e}\")\n    finally:\n        # Final invariant: if process_name is non-empty, either a valid process_handle exists or an exception was caught\n        if process_name.strip() != '' and process_handle is None:\n            print(f\"Warning: Non-empty command '{process_name}' did not yield a valid process handle.\")\n\n    # Function should not return anything.\n    result = None\n    # Assert that the function returns None explicitly\n    assert result is None, f\"Return value must be None, got {result} instead.\"\n    return", "testing": false, "error_message": "FFF\n======================================================================\nFAIL: test_process_found_restarts_process (__test__.TestCases.test_process_found_restarts_process)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 255, in test_process_found_restarts_process\n    result = task_func('notepad')\n  File \"/tmp/testing_python_program.py\", line 54, in task_func\n    processes = get_processes_by_name(process_name)\n  File \"/tmp/testing_python_program.py\", line 113, in get_processes_by_name\n    assert isinstance(proc_name, str), f\"Process name should be a string, got {type(proc_name)} for PID {getattr(proc, 'pid', 'Unknown')}\"\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^\nAssertionError: Process name should be a string, got <class 'unittest.mock.MagicMock'> for PID <MagicMock name='mock.pid' id='4371136000'>\n\n======================================================================\nFAIL: test_process_not_found_starts_process (__test__.TestCases.test_process_not_found_starts_process)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 247, in test_process_not_found_starts_process\n    mock_popen.assert_called_once_with('random_non_existent_process')\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 989, in assert_called_once_with\n    return self.assert_called_with(*args, **kwargs)\n           ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 977, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: Popen('random_non_existent_process')\n  Actual: Popen('random_non_existent_process', shell=True)\n\n======================================================================\nFAIL: test_process_terminates_and_restarts_multiple_instances (__test__.TestCases.test_process_terminates_and_restarts_multiple_instances)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python@3.13/3.13.2/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py\", line 1424, in patched\n    return func(*newargs, **newkeywargs)\n  File \"/tmp/testing_python_program.py\", line 269, in test_process_terminates_and_restarts_multiple_instances\n    result = task_func('multi_instance')\n  File \"/tmp/testing_python_program.py\", line 54, in task_func\n    processes = get_processes_by_name(process_name)\n  File \"/tmp/testing_python_program.py\", line 113, in get_processes_by_name\n    assert isinstance(proc_name, str), f\"Process name should be a string, got {type(proc_name)} for PID {getattr(proc, 'pid', 'Unknown')}\"\n           ~~~~~~~~~~^^^^^^^^^^^^^^^^\nAssertionError: Process name should be a string, got <class 'unittest.mock.MagicMock'> for PID <MagicMock name='mock.pid' id='4371129616'>\n\n----------------------------------------------------------------------\nRan 3 tests in 0.010s\n\nFAILED (failures=3)\n"}, "4": {"task_id": "BigCodeBench/19", "function_name": "task_func", "code": "import os\n\n\ndef check_directory_exists(directory: str) -> None:\n    # Assert input type\n    assert isinstance(directory, str), f\"check_directory_exists: directory must be a string; got {type(directory).__name__} (directory={directory})\"\n    # Actual implementation should check if the directory exists, if not, raise FileNotFoundError\n    # For now, we leave implementation empty\n    pass\n\n\ndef gather_files(directory: str) -> list:\n    # Assert input type\n    assert isinstance(directory, str), f\"gather_files: directory must be a string; got {type(directory).__name__} (directory={directory})\"\n    # Actual implementation should return a list of file paths (only files, not subdirectories)\n    # For now, we leave implementation empty\n    return []\n\n\ndef zip_files(files: list, directory: str) -> str:\n    # Assert input types\n    assert isinstance(files, list), f\"zip_files: files must be a list; got {type(files).__name__} (files={files})\"\n    assert isinstance(directory, str), f\"zip_files: directory must be a string; got {type(directory).__name__} (directory={directory})\"\n    # Actual implementation should zip the files into 'files.zip' and return the zip file path\n    # For now, we leave implementation empty\n    return ''\n\n\ndef task_func(directory: str) -> str:\n    assert isinstance(directory, str), f\"task_func: directory must be a string; got {type(directory).__name__} (directory={directory})\"\n    assert directory, f\"task_func: directory should not be an empty string (directory={directory})\"\n\n    check_directory_exists(directory)\n\n    files = gather_files(directory)\n    assert isinstance(files, list), f\"task_func: gather_files should return a list; got {type(files).__name__} (directory={directory}, files={files})\"\n\n    if not files:\n        return None\n\n    # Loop invariant: each file in files must be a string and should be a valid file path\n    for file in files:\n        assert isinstance(file, str), f\"task_func: each file must be a string; got {type(file).__name__} (file={file})\"\n        # Here we check that the file exists and is indeed a file\n        full_path = file if os.path.isabs(file) else os.path.join(directory, file)\n        assert os.path.isfile(full_path), f\"task_func: file does not exist or is not a file (full_path={full_path}, directory={directory})\"\n\n    zip_path = zip_files(files, directory)\n    assert isinstance(zip_path, str), f\"task_func: zip_files should return a string; got {type(zip_path).__name__} (zip_path={zip_path}, directory={directory}, files={files})\"\n    \n    # Final output invariant: the zip file must be named 'files.zip'\n    zip_file_name = os.path.basename(zip_path)\n    assert zip_file_name == 'files.zip', f\"task_func: The zip file name must be 'files.zip'; got {zip_file_name} (zip_path={zip_path})\"\n    \n    return zip_path\n\nimport os\n\ndef check_directory_exists(directory: str) -> None:\n    # Input assertion: check that the directory parameter is a string\n    assert isinstance(directory, str), f\"Input error: Expected 'directory' to be a string, got {type(directory).__name__} (value: {directory})\"\n\n    # Check if the directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"The directory '{directory}' does not exist.\")\n\n    # Postcondition: ensure that the directory exists\n    assert os.path.isdir(directory), f\"Postcondition error: Directory '{directory}' should exist at this point but does not.\"\n    return\n\n\nimport os\n\ndef gather_files(directory: str) -> list[str]:\n    # Input assertion: directory must be a string\n    assert isinstance(directory, str), f\"Expected directory as str, got {type(directory).__name__}\"\n    \n    # Ensure the directory exists and is a directory\n    assert os.path.exists(directory), f\"Directory does not exist: {directory}\"\n    assert os.path.isdir(directory), f\"Provided path is not a directory: {directory}\"\n\n    files_list = []\n    # Loop over the items in the directory\n    items = os.listdir(directory)\n    # Loop invariant: items should be a list of strings\n    assert isinstance(items, list) and all(isinstance(item, str) for item in items), f\"os.listdir({directory}) did not return list of strs\"\n\n    for item in items:\n        # Create the full path\n        full_path = os.path.join(directory, item)\n        # Loop invariant: full_path should be a string\n        assert isinstance(full_path, str), f\"full_path is not a string: {full_path}\"\n        \n        # Check if it's a file (not a directory)\n        if os.path.isfile(full_path):\n            files_list.append(full_path)\n            # In-loop assertion: each added element should be an existing file\n            assert os.path.exists(full_path), f\"File does not exist: {full_path}\"\n\n    # Output assertion: ensure result is a list of strings\n    assert isinstance(files_list, list) and all(isinstance(f, str) for f in files_list), f\"Output files_list must be a list of strings, got: {files_list}\"\n    return files_list\n\n\nimport os\nimport zipfile\n\ndef zip_files(file_list: list[str], directory: str) -> str:\n    # Input assertions\n    assert isinstance(file_list, list), f\"file_list must be a list, got type {type(file_list)}\"\n    for f in file_list:\n        assert isinstance(f, str), f\"Each file in file_list must be a string, got {f} of type {type(f)}\"\n    assert isinstance(directory, str), f\"directory must be a string, got type {type(directory)}\"\n    \n    # Check that the output directory exists\n    assert os.path.isdir(directory), f\"The provided directory does not exist: {directory}\"\n    \n    # Create the path for the zip file\n    zip_path = os.path.join(directory, 'files.zip')\n    \n    # Use the zipfile module to create the zip file\n    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for file in file_list:\n            # Loop invariant: file is a string and zipf is a valid ZipFile object\n            assert isinstance(file, str), f\"Loop invariant failed: file must be a string, got {file}\"\n            assert hasattr(zipf, 'write'), f\"zipf should have a write method\"\n            \n            # Ensure that file exists\n            if os.path.isfile(file):\n                # Add file to the archive\n                arcname = os.path.basename(file)\n                zipf.write(file, arcname=arcname)\n                # In-loop assertion: arcname should be non-empty\n                assert arcname, f\"arcname derived from {file} is empty\"\n            else:\n                raise FileNotFoundError(f\"The file {file} does not exist.\")\n                \n    # Output assertion: verify that the zip file was created and has the expected name\n    assert os.path.isfile(zip_path), f\"Zip file was not created at {zip_path}\"\n    expected_zip_path = os.path.join(directory, 'files.zip')\n    assert zip_path == expected_zip_path, f\"Output zip path {zip_path} does not match expected {expected_zip_path}\"\n\n    # Optional post-condition check: verify contents of the zip file\n    with zipfile.ZipFile(zip_path, 'r') as zipf:\n        zip_contents = zipf.namelist()\n        for file in file_list:\n            base_name = os.path.basename(file)\n            assert base_name in zip_contents, f\"File {base_name} not found in zip archive {zip_contents}\"\n\n    # Final output assertion: return type must be string\n    assert isinstance(zip_path, str), f\"Return value must be a string, got {type(zip_path)}\"\n    return zip_path\n", "testing": true, "error_message": null}, "5": {"task_id": "BigCodeBench/34", "function_name": "task_func", "code": "from wordcloud import WordCloud\n\n\ndef task_func(text: str) -> WordCloud:\n    # Assert that the input text is a string\n    assert isinstance(text, str), f\"Input 'text' must be of type str, got {type(text)} with value {text}\"\n\n    # Step 1: Clean the text by removing URLs\n    cleaned_text = remove_urls_from_text(text)\n    # Assert that remove_urls_from_text returns a string\n    assert isinstance(cleaned_text, str), f\"Expected cleaned_text to be str, got {type(cleaned_text)} with value {cleaned_text}\"\n\n    # Step 2: Validate that text is not empty after cleaning\n    if not cleaned_text.strip():\n        raise ValueError(\"No words available to generate a word cloud after removing URLs.\")\n    # Invariant: cleaned_text should have at least one non-whitespace character\n    assert cleaned_text.strip(), f\"After cleaning, text is empty. Original text was: {text} and cleaned_text: {cleaned_text}\"\n\n    # Step 3: Generate word cloud\n    wordcloud_obj = generate_wordcloud_from_text(cleaned_text)\n    # Assert that generate_wordcloud_from_text returns a WordCloud instance\n    assert isinstance(wordcloud_obj, WordCloud), f\"Expected generate_wordcloud_from_text to return a WordCloud instance, got {type(wordcloud_obj)}\"\n\n    # If wordcloud object has words_, check it is a dictionary (if defined)\n    if hasattr(wordcloud_obj, 'words_'):\n        assert isinstance(wordcloud_obj.words_, dict), f\"Expected wordcloud_obj.words_ to be a dict, got {type(wordcloud_obj.words_)} with value {wordcloud_obj.words_}\"\n\n    # Step 4: Plot the word cloud\n    plot_wordcloud(wordcloud_obj)\n\n    # Final post-condition: output must be a WordCloud instance with non-empty words_ attribute if available\n    assert isinstance(wordcloud_obj, WordCloud), f\"Output must be a WordCloud, got {type(wordcloud_obj)}\"\n    if hasattr(wordcloud_obj, 'words_'):\n        assert isinstance(wordcloud_obj.words_, dict), f\"Output wordcloud.words_ must be a dict, got {type(wordcloud_obj.words_)}\"\n        assert wordcloud_obj.words_, f\"Output wordcloud.words_ is empty: {wordcloud_obj.words_}\"\n    \n    return wordcloud_obj\n\nimport re\n\ndef remove_urls_from_text(text: str) -> str:\n    # Input assertion: ensure the provided text is a string\n    assert isinstance(text, str), f\"Input must be of type str; got {type(text)} with value: {text}\"\n\n    url_pattern = r'https?://\\S+'\n\n    # Substitute all occurrences of the url_pattern with an empty string\n    cleaned_text = re.sub(url_pattern, '', text)\n\n    # Output assertion: ensure the output is a string\n    assert isinstance(cleaned_text, str), f\"Output must be of type str; got {type(cleaned_text)} with value: {cleaned_text}\"\n\n    # Loop invariant / post-condition: cleaned_text should not contain any substring matching the url_pattern\n    match = re.search(url_pattern, cleaned_text)\n    assert match is None, f\"Output text still contains a URL match: {match.group(0)} in text: {cleaned_text}\"\n\n    return cleaned_text\n\nfrom wordcloud import WordCloud\n\ndef generate_wordcloud_from_text(cleaned_text: str) -> WordCloud:\n    # Input assertion: cleaned_text must be of type str and not empty\n    assert isinstance(cleaned_text, str), f\"Input cleaned_text must be str, got {type(cleaned_text)}\"\n    assert len(cleaned_text) > 0, \"Input cleaned_text must be non-empty\"\n\n    # Create an instance of WordCloud\n    wc = WordCloud()\n    # Generate the word cloud from the cleaned text\n    output = wc.generate(cleaned_text)\n    \n    # Output assertion: output must be WordCloud, and string should be reflected in words\n    assert isinstance(output, WordCloud), f\"Output must be a WordCloud object, got {type(output)}\"\n    \n    # Internal check: if words are generated, verify that the word frequencies are not empty\n    # Here we assume that generate() fills in the 'words_' attribute if words were found\n    if hasattr(output, 'words_'):\n        assert isinstance(output.words_, dict), f\"WordCloud.words_ must be a dict, got {type(output.words_)}\"\n        assert len(output.words_) > 0, \"WordCloud.words_ should contain at least one word\"\n\n    # Final assertion: verify that output, when re-generated, actually corresponds to input text behavior\n    # This is a rough invariant check based on the size of the text\n    assert len(cleaned_text.split()) > 0, f\"Input cleaned_text should contain tokens, got {cleaned_text}\"\n\n    return output\n\ndef plot_wordcloud(wordcloud: 'WordCloud') -> None:\n    assert hasattr(wordcloud, 'to_array') or hasattr(wordcloud, 'layout_'), \\\n        f\"Input must be a WordCloud object: missing 'to_array' or 'layout_' attribute. Got attributes: {dir(wordcloud)}\"\n\n    import matplotlib.pyplot as plt\n\n    fig = plt.figure()\n    assert fig is not None, f\"Failed to create a matplotlib figure. fig is {fig}\"\n\n    image_obj = plt.imshow(wordcloud, interpolation='bilinear')\n    assert image_obj is not None, f\"plt.imshow returned None, check if 'wordcloud' is a valid WordCloud object. wordcloud: {wordcloud}\"\n\n    plt.axis('off')\n    current_axes = plt.gca()\n    xticks = current_axes.get_xticks()\n    yticks = current_axes.get_yticks()\n    assert len(xticks) == 0, f\"X ticks should be removed, but found: {xticks}\"\n    assert len(yticks) == 0, f\"Y ticks should be removed, but found: {yticks}\"\n\n    plt.show()\n\n    result = None\n    assert result is None, f\"Output of plot_wordcloud should be None, got: {result}\"", "testing": false, "error_message": "Traceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 3, in <module>\n    from wordcloud import WordCloud\nModuleNotFoundError: No module named 'wordcloud'\n"}, "6": {"task_id": "BigCodeBench/37", "function_name": "task_func", "code": "def task_func(df: pd.DataFrame, target_column: str) -> tuple[RandomForestClassifier, plt.Axes]:\n    # Input assertions\n    assert isinstance(df, pd.DataFrame), f\"df must be a pandas DataFrame, got {type(df)}\"\n    assert isinstance(target_column, str), f\"target_column must be a string, got {type(target_column)}\"\n    assert target_column in df.columns, f\"target_column '{target_column}' not found in DataFrame columns: {df.columns.to_list()}\"\n\n    # Split into features and target\n    X, y = split_features_target(df, target_column)\n    # Check that X is a DataFrame and doesn't contain the target_column\n    assert isinstance(X, pd.DataFrame), f\"X must be a pandas DataFrame after splitting, got {type(X)}\"\n    assert target_column not in X.columns, f\"X should not contain the target column '{target_column}'. Current columns: {X.columns.to_list()}\"\n    # Check that y has the same number of rows as X\n    assert len(y) == len(X), f\"Mismatch in rows: len(y)={len(y)} and len(X)={len(X)}\"\n\n    # Train random forest model\n    model = train_random_forest(X, y)\n\n    # Assert that the model is of correct type\n    from sklearn.ensemble import RandomForestClassifier\n    assert isinstance(model, RandomForestClassifier), f\"Expected model to be a RandomForestClassifier, got {type(model)}\"\n\n    # Plot feature importance\n    feature_names = X.columns.to_list()\n    ax = plot_feature_importance(model, feature_names)\n\n    # Assert that ax is a matplotlib Axes object\n    import matplotlib.axes as maxes\n    assert isinstance(ax, maxes.Axes), f\"Expected ax to be a matplotlib Axes instance, got {type(ax)}\"\n\n    # Verify plot labels and title\n    xlabel = ax.get_xlabel()\n    ylabel = ax.get_ylabel()\n    title = ax.get_title()\n    assert xlabel == 'Feature Importance Score', f\"Expected x-axis label 'Feature Importance Score', got '{xlabel}'\"\n    assert ylabel == 'Features', f\"Expected y-axis label 'Features', got '{ylabel}'\"\n    assert title == 'Visualizing Important Features', f\"Expected title 'Visualizing Important Features', got '{title}'\"\n\n    return model, ax\n\nimport pandas as pd\n\ndef split_features_target(df: pd.DataFrame, target_column: str) -> tuple[pd.DataFrame, pd.Series]:\n    # Input assertions\n    assert isinstance(df, pd.DataFrame), f\"Expected df to be a pandas DataFrame, got {type(df)} instead\"\n    assert isinstance(target_column, str), f\"Expected target_column to be a str, got {type(target_column)} instead\"\n    assert target_column in df.columns, f\"target_column '{target_column}' not found in DataFrame columns {list(df.columns)}\"\n\n    # Split the DataFrame into features and target\n    X = df.drop(columns=[target_column])\n    y = df[target_column]\n    \n    # Intermediate assertions\n    # Assert that the shape of X remains the same number of rows as df\n    assert X.shape[0] == df.shape[0], f\"The features DataFrame X should have the same number of rows as df. Got X rows: {X.shape[0]}, df rows: {df.shape[0]}\"\n    # Check that target_column has been removed from X\n    assert target_column not in X.columns, f\"target_column '{target_column}' should not appear in X.columns. Current X.columns: {list(X.columns)}\"\n\n    # Output assertions\n    assert isinstance(X, pd.DataFrame), f\"Output X must be a pandas DataFrame, got {type(X)}\"\n    assert isinstance(y, pd.Series), f\"Output y must be a pandas Series, got {type(y)}\"\n    \n    # Final invariant: Check that recombining X and y recreates df columns (order may differ)\n    expected_feature_cols = [col for col in df.columns if col != target_column]\n    assert set(X.columns) == set(expected_feature_cols), f\"X.columns {list(X.columns)} do not match expected feature columns {expected_feature_cols}\"\n    \n    return X, y\n\n\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier\n\ndef train_random_forest(X: pd.DataFrame, y: pd.Series) -> RandomForestClassifier:\n    # Check input types\n    assert isinstance(X, pd.DataFrame), f\"X must be a pandas DataFrame, got {type(X)}\"\n    assert isinstance(y, pd.Series), f\"y must be a pandas Series, got {type(y)}\"\n    # Check that X and y have the same length\n    assert len(X) == len(y), f\"X and y must have the same length; got len(X)={len(X)} and len(y)={len(y)}\"\n    # Check that inputs are not empty\n    assert not X.empty, f\"Input DataFrame X is empty with shape {X.shape}\" \n    assert len(y) > 0, f\"Input Series y is empty, length is {len(y)}\"\n\n    # Create the RandomForestClassifier instance\n    model = RandomForestClassifier()\n\n    # Fit the model\n    model.fit(X, y)\n\n    # Post-fit assertion: check that the model has been trained by verifying 'estimators_' attribute is set\n    assert hasattr(model, 'estimators_'), f\"Model did not get fitted properly; missing attribute 'estimators_'. Available attributes: {dir(model)}\"\n    # Check that there is at least one estimator\n    num_estimators = len(model.estimators_)\n    assert num_estimators > 0, f\"Model should have at least one estimator after fitting, got {num_estimators}\"\n\n    # Loop invariant: Each estimator in model.estimators_ must be a valid fitted estimator\n    for idx, estimator in enumerate(model.estimators_):\n        assert estimator is not None, f\"Estimator at index {idx} is None\"\n        # Optionally, check that each estimator has been fitted: 'tree_' attribute exists for DecisionTreeRegressor\n        assert hasattr(estimator, 'tree_'), f\"Estimator at index {idx} does not have 'tree_' attribute, indicating it might not be fitted\"\n\n    # Additional output assertion: the model should report the correct number of features in input\n    if hasattr(model, 'n_features_in_'):\n        num_features = X.shape[1]\n        assert model.n_features_in_ == num_features, \\\n            f\"Model reports n_features_in_={model.n_features_in_} but X has {num_features} features\"\n\n    # Final output assertion: ensure model is an instance of RandomForestClassifier\n    assert isinstance(model, RandomForestClassifier), f\"Returned model is not an instance of RandomForestClassifier, got {type(model)}\"\n\n    return model\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.ensemble import RandomForestClassifier\n\n\ndef plot_feature_importance(model: RandomForestClassifier, feature_names: list[str]) -> plt.Axes:\n    # Input assertions\n    assert isinstance(model, RandomForestClassifier), f\"Expected model to be RandomForestClassifier, got {type(model)}\"\n    assert isinstance(feature_names, list), f\"Expected feature_names to be a list, got {type(feature_names)}\"\n    assert all(isinstance(fn, str) for fn in feature_names), f\"All feature_names must be strings. Received: {feature_names}\"\n\n    # Get the feature importances from the model\n    importances = model.feature_importances_\n    # Assert that importances is a numpy array and one-dimensional\n    assert isinstance(importances, np.ndarray), f\"Expected model.feature_importances_ to be np.ndarray, got {type(importances)}\"\n    assert importances.ndim == 1, f\"Expected feature_importances_ to be one-dimensional, got shape {importances.shape}\"\n\n    # Ensure the feature_names list matches the number of features\n    assert len(feature_names) == len(importances), f\"Length of feature_names ({len(feature_names)}) must match number of features ({len(importances)})\"\n\n    # Sort the feature importances in descending order\n    indices = np.argsort(importances)[::-1]\n    # Loop invariant: ensure that indices array length matches importances length\n    assert len(indices) == len(importances), f\"Length of indices ({len(indices)}) does not match number of features ({len(importances)})\"\n\n    sorted_importances = importances[indices]\n    sorted_feature_names = [feature_names[i] for i in indices]\n    # Loop invariant: for each index in indices, ensure it is a valid index for feature_names\n    for idx in indices:\n        assert 0 <= idx < len(feature_names), f\"Index {idx} out of bounds for feature_names of length {len(feature_names)}\"\n    assert len(sorted_feature_names) == len(sorted_importances), f\"Lengths of sorted_feature_names ({len(sorted_feature_names)}) and sorted_importances ({len(sorted_importances)}) must match\"\n    \n    # Check the ordering of sorted_importances is in descending order\n    for i in range(len(sorted_importances) - 1):\n        assert sorted_importances[i] >= sorted_importances[i+1], f\"Feature importances not sorted in descending order at position {i}: {sorted_importances[i]} < {sorted_importances[i+1]}\"\n\n    # Create a bar plot\n    fig, ax = plt.subplots()\n    ax.bar(range(len(sorted_importances)), sorted_importances, align='center')\n    ax.set_xticks(range(len(sorted_importances)))\n    ax.set_xticklabels(sorted_feature_names, rotation=45, ha='right')\n    ax.set_ylabel('Importance')\n    ax.set_title('Feature Importances')\n    plt.tight_layout()\n    \n    # Output assertions: ensure ax is an Axes instance\n    from matplotlib.axes import Axes\n    assert isinstance(ax, Axes), f\"Returned object ax is not an instance of matplotlib.axes.Axes, got {type(ax)}\"\n    \n    return ax", "testing": false, "error_message": "Traceback (most recent call last):\n  File \"/tmp/testing_python_program.py\", line 4, in <module>\n    import seaborn as sns\nModuleNotFoundError: No module named 'seaborn'\n"}}}